{"version":3,"sources":["../node_modules/agora-rworldle/dist/index.js"],"names":["__assign","this","Object","assign","t","s","i","n","arguments","length","p","prototype","hasOwnProperty","call","apply","__importDefault","mod","__esModule","defineProperty","exports","value","lodash_1","require","agora_graph_1","hasOverlap","alreadyLayouted","current","_i","alreadyLayouted_1","overlap","rWordleL","createFunction","graph","options","padding","nodes","sort","a","b","x","layouted","default","forEach","cur","minSide","Math","min","width","height","spiralFactor","spiralStep","tx","sin","ty","cos","transformedArea","sum","y","push","RWordleLAlgorithm","name","algorithm"],"mappings":"iGAwBA,IAAIA,EAAYC,MAAQA,KAAKD,UAAa,WAStC,OARAA,EAAWE,OAAOC,QAAU,SAASC,GACjC,IAAK,IAAIC,EAAGC,EAAI,EAAGC,EAAIC,UAAUC,OAAQH,EAAIC,EAAGD,IAE5C,IAAK,IAAII,KADTL,EAAIG,UAAUF,GACOJ,OAAOS,UAAUC,eAAeC,KAAKR,EAAGK,KACzDN,EAAEM,GAAKL,EAAEK,IAEjB,OAAON,IAEKU,MAAMb,KAAMO,YAE5BO,EAAmBd,MAAQA,KAAKc,iBAAoB,SAAUC,GAC9D,OAAQA,GAAOA,EAAIC,WAAcD,EAAM,CAAE,QAAWA,IAExDd,OAAOgB,eAAeC,EAAS,aAAc,CAAEC,OAAO,IACtD,IAAIC,EAAWN,EAAgBO,EAAQ,IACnCC,EAAgBD,EAAQ,IAiC5B,SAASE,EAAWC,EAAiBC,GACjC,IAAK,IAAIC,EAAK,EAAGC,EAAoBH,EAAiBE,EAAKC,EAAkBnB,OAAQkB,IAAM,CACvF,IAAItB,EAAIuB,EAAkBD,GAC1B,GAAIJ,EAAcM,QAAQxB,EAAGqB,GACzB,OAAO,EAGf,OAAO,EAvCXP,EAAQW,SAAWP,EAAcQ,gBAAe,SAAUC,EAAOC,QAC7C,IAAZA,IAAsBA,EAAU,CAAEC,QAAS,IAE/CF,EAAMG,MAAMC,MAAK,SAAUC,EAAGC,GAAK,OAAOD,EAAEE,EAAID,EAAEC,KAClD,IAAIC,EAAW,GAqBf,OApBAnB,EAASoB,QAAQC,QAAQV,EAAMG,OAAO,SAAUQ,GAM5C,IALA,IAAIvC,EAAI,EACJwC,EAAUC,KAAKC,IAAIH,EAAII,MAAOJ,EAAIK,QAElCC,EAAeL,EAAU,GACzBM,EAAaN,EAAU,KACd,CACT,IAAIO,EAAKN,KAAKO,IAAIhD,GAAKA,EAAI6C,EACvBI,EAAKR,KAAKS,IAAIlD,GAAKA,EAAI6C,EAEvBM,EAAkBvD,EAASA,EAAS,GAAI2C,GAAMpB,EAAciC,IAAIb,EAAK,CAAEJ,EAAGY,EAAIM,EAAGJ,KACrF,IAAK7B,EAAWgB,EAAUe,GAAkB,CAExCf,EAASkB,KAAKH,GACd,MAEJnD,GAAK8C,EAAa9C,MAG1B4B,EAAMG,MAAQK,EACP,CAAER,MAAOA,MAEpBb,EAAQwC,kBAAoB,CACxBC,KAAM,WACNC,UAAW1C,EAAQW,UAEvBX,EAAQsB,QAAUtB,EAAQW","file":"static/js/17.299f4b80.chunk.js","sourcesContent":["\"use strict\";\r\n/**\r\n * Implementation of RWordle-L Algorithm\r\n *\r\n * Ported from Java, original code owned by :\r\n * Copyright by Marc Spicker\r\n * GPL License -- http://www.gnu.org/licenses/gpl.html\r\n *\r\n * based on the publication:\r\n * @article {CGF:CGF3106,\r\n *  author = {Strobelt, H. and Spicker, M. and Stoffel, A. and Keim, D. and Deussen, O.},\r\n *  title = {Rolled-out Wordles: A Heuristic Method for Overlap Removal of 2D Data Representatives},\r\n *  journal = {Computer Graphics Forum},\r\n *  volume = {31},\r\n *  number = {3pt3},\r\n *  publisher = {Blackwell Publishing Ltd},\r\n *  issn = {1467-8659},\r\n *  url = {http://dx.doi.org/10.1111/j.1467-8659.2012.03106.x},\r\n *  doi = {10.1111/j.1467-8659.2012.03106.x},\r\n *  pages = {1135--1144},\r\n *  keywords = {I.3.3 [Computer Graphics]: Picture/Image Generationâ€”Line and curve generation},\r\n *  year = {2012},\r\n * }\r\n */\r\nvar __assign = (this && this.__assign) || function () {\r\n    __assign = Object.assign || function(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\r\n                t[p] = s[p];\r\n        }\r\n        return t;\r\n    };\r\n    return __assign.apply(this, arguments);\r\n};\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar lodash_1 = __importDefault(require(\"lodash\"));\r\nvar agora_graph_1 = require(\"agora-graph\");\r\nexports.rWordleL = agora_graph_1.createFunction(function (graph, options) {\r\n    if (options === void 0) { options = { padding: 0 }; }\r\n    // Sort by Xs\r\n    graph.nodes.sort(function (a, b) { return a.x - b.x; });\r\n    var layouted = [];\r\n    lodash_1.default.forEach(graph.nodes, function (cur) {\r\n        var t = 3.0;\r\n        var minSide = Math.min(cur.width, cur.height);\r\n        // spiral depending on the size of the object\r\n        var spiralFactor = minSide / 17.0;\r\n        var spiralStep = minSide / 10.0;\r\n        while (true) {\r\n            var tx = Math.sin(t) * t * spiralFactor;\r\n            var ty = Math.cos(t) * t * spiralFactor;\r\n            // transformed object\r\n            var transformedArea = __assign(__assign({}, cur), agora_graph_1.sum(cur, { x: tx, y: ty }));\r\n            if (!hasOverlap(layouted, transformedArea)) {\r\n                // found placement\r\n                layouted.push(transformedArea);\r\n                break;\r\n            }\r\n            t += spiralStep / t;\r\n        }\r\n    });\r\n    graph.nodes = layouted;\r\n    return { graph: graph };\r\n});\r\nexports.RWordleLAlgorithm = {\r\n    name: 'RWordleL',\r\n    algorithm: exports.rWordleL\r\n};\r\nexports.default = exports.rWordleL;\r\nfunction hasOverlap(alreadyLayouted, current) {\r\n    for (var _i = 0, alreadyLayouted_1 = alreadyLayouted; _i < alreadyLayouted_1.length; _i++) {\r\n        var s = alreadyLayouted_1[_i];\r\n        if (agora_graph_1.overlap(s, current)) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\r\n"],"sourceRoot":""}