{"version":3,"sources":["../node_modules/agora-scaling/node_modules/agora-graph/dist/point.js","../node_modules/agora-scaling/node_modules/agora-graph/dist/box.js","../node_modules/agora-scaling/node_modules/agora-graph/dist/vector.js","../node_modules/agora-scaling/node_modules/agora-graph/dist/overlap.js","../node_modules/agora-scaling/node_modules/agora-graph/dist/index.js","../node_modules/agora-scaling/node_modules/agora-graph/dist/algorithm.js","../node_modules/agora-scaling/node_modules/agora-graph/dist/conversion.js","../node_modules/agora-scaling/node_modules/agora-graph/dist/cropped.js","../node_modules/agora-scaling/node_modules/agora-graph/dist/delaunay-edges.js","../node_modules/agora-scaling/node_modules/agora-graph/dist/distance.js","../node_modules/agora-scaling/node_modules/agora-graph/dist/node-map.js","../node_modules/agora-scaling/node_modules/agora-graph/dist/scale.js","../node_modules/agora-scaling/dist/index.js"],"names":["delta","p1","p2","x","deltaX","y","deltaY","Object","defineProperty","exports","value","Δ","Δx","Δy","normX","Math","abs","normY","norm","hypot","__importDefault","this","mod","__esModule","lodash_1","minX","node","Array","default","minBy","v","width","maxX","maxBy","minY","height","maxY","setHeight","n","yMin","yMax","setWidth","xMin","xMax","setMinY","setMaxY","setMinX","setMaxX","diagonal","box","left","right","top","bottom","setTop","setBottom","setLeft","setRight","point_1","magnitude","vector","length","sum","v1","v2","diff","mult","k","box_1","overlap","n1","n2","padding","overlapX","overlapY","hasOverlap","nodes","lap","sorted","sortBy","forEach","index","j","edgeOverlap","map","edges","present","edge","source","target","getAllOverlaps","overlaps","push","__export","m","p","hasOwnProperty","createFunction","f","vector_1","ROUND_PRECISION","round","number","precision","multiplier","pow","toCartesian","cos","theta","sin","toPolar","rad","atan2","PI","angle","crop","graph","delaunator_1","overlap_1","delaunay","del","from","hastable","triangles","chunk","triangle","sort","a","b","c","addable","i","augmented","edges1","edges2","_a","iterated","iteratee","added","e1","empty","e2","concat","merge","pair","optimalVector","desired","actual","widthRatio","heightRatio","unOverlapRatio","min","minimalVector","Δx_n1n2","Δy_n1n2","nodeMap","aggreg","createScale","initial","frame","scale","ratio","agora_graph_1","scaling","options","scaleRatio","maxOverlapRatio","overlapGroups","group","u","actualDist","getMaxOverlapRatio","x_origin","y_origin","ScalingAlgorithm","name","algorithm"],"mappings":"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","file":"static/js/9.044c1523.chunk.js","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\r\n * @param {Point} p1 first point\r\n * @param {Point} p2 second point\r\n *\r\n * @returns creates a vector (p1, p2) using p1,p2\r\n */\n\nfunction delta(p1, p2) {\n  return {\n    x: deltaX(p1, p2),\n    y: deltaY(p1, p2)\n  };\n}\n\nexports.delta = delta;\nexports.Δ = delta;\n/**\r\n * @param {Point} p1\r\n * @param {Point} p2\r\n *\r\n * @returns {number} the Δ (x axis) between two points\r\n */\n\nfunction deltaX(p1, p2) {\n  return p2.x - p1.x;\n}\n\nexports.deltaX = deltaX;\nexports.Δx = deltaX;\n/**\r\n * @param {Point} p1\r\n * @param {Point} p2\r\n *\r\n * @returns {number} the Δ (y axis) between two points\r\n */\n\nfunction deltaY(p1, p2) {\n  return p2.y - p1.y;\n}\n\nexports.deltaY = deltaY;\nexports.Δy = deltaY;\n/**\r\n * @param {Point} p1\r\n * @param {Point} p2\r\n *\r\n * @returns {number} the norm (x axis) between two points\r\n */\n\nfunction normX(p1, p2) {\n  return Math.abs(deltaX(p1, p2));\n}\n\nexports.normX = normX;\n/**\r\n * @param {Point} p1\r\n * @param {Point} p2\r\n *\r\n * @returns {number} the norm (y axis) between two points\r\n */\n\nfunction normY(p1, p2) {\n  return Math.abs(deltaY(p1, p2));\n}\n\nexports.normY = normY;\n/**\r\n * @returns Distance between two points\r\n * @param p1\r\n * @param p2\r\n */\n\nfunction norm(p1, p2) {\n  return Math.hypot(deltaX(p1, p2), deltaY(p1, p2));\n}\n\nexports.norm = norm;","\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar lodash_1 = __importDefault(require(\"lodash\"));\n/**\r\n * diagonal length of the box\r\n * @param box\r\n */\n\n\nfunction diagonal(box) {\n  return Math.hypot(box.width, box.height);\n}\n\nexports.diagonal = diagonal;\n\nfunction minX(node) {\n  if (node instanceof Array) return lodash_1.default.minBy(node, function (v) {\n    return minX(v);\n  });\n  return node.x - node.width / 2;\n}\n\nexports.minX = minX;\nexports.left = minX;\n\nfunction maxX(node) {\n  if (node instanceof Array) return lodash_1.default.maxBy(node, function (v) {\n    return maxX(v);\n  });\n  return node.x + node.width / 2;\n}\n\nexports.maxX = maxX;\nexports.right = maxX;\n\nfunction minY(node) {\n  if (node instanceof Array) return lodash_1.default.minBy(node, function (v) {\n    return minY(v);\n  });\n  return node.y - node.height / 2;\n}\n\nexports.minY = minY;\nexports.top = minY;\n\nfunction maxY(node) {\n  if (node instanceof Array) return lodash_1.default.maxBy(node, function (v) {\n    return maxY(v);\n  });\n  return node.y + node.height / 2;\n}\n\nexports.maxY = maxY;\nexports.bottom = maxY;\n\nfunction setHeight(n, yMin, yMax) {\n  n.height = yMax - yMin;\n  return n;\n}\n\nexports.setHeight = setHeight;\n\nfunction setWidth(n, xMin, xMax) {\n  n.width = xMax - xMin;\n  return n;\n}\n\nexports.setWidth = setWidth;\n\nfunction setMinY(n, yMin) {\n  setHeight(n, yMin, maxY(n));\n  n.y = n.height / 2 + yMin;\n  return n;\n}\n\nexports.setMinY = setMinY;\nexports.setTop = setMinY;\n\nfunction setMaxY(n, yMax) {\n  var yMin = minY(n);\n  setHeight(n, yMin, yMax);\n  n.y = n.height / 2 + yMin;\n  return n;\n}\n\nexports.setMaxY = setMaxY;\nexports.setBottom = setMaxY;\n\nfunction setMinX(n, xMin) {\n  setWidth(n, xMin, maxX(n));\n  n.x = n.width / 2 + xMin;\n  return n;\n}\n\nexports.setMinX = setMinX;\nexports.setLeft = setMinX;\n\nfunction setMaxX(n, xMax) {\n  var xMin = minX(n);\n  setWidth(n, xMin, xMax);\n  n.x = n.width / 2 + xMin;\n  return n;\n}\n\nexports.setMaxX = setMaxX;\nexports.setRight = setMaxX;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar point_1 = require(\"./point\");\n\nexports.vector = point_1.delta;\n/**\r\n * length of the vector\r\n * @param vector\r\n */\n\nfunction magnitude(vector) {\n  return Math.hypot(vector.x, vector.y);\n}\n\nexports.magnitude = magnitude;\nexports.length = magnitude;\n/**\r\n * Sums two vectors\r\n * @param v1\r\n * @param v2\r\n */\n\nfunction sum(v1, v2) {\n  return {\n    x: v1.x + v2.x,\n    y: v1.y + v2.y\n  };\n}\n\nexports.sum = sum;\n/**\r\n * substract vector v1 - v2\r\n * @param v1\r\n * @param v2\r\n */\n\nfunction diff(v1, v2) {\n  return {\n    x: v1.x - v2.x,\n    y: v1.y - v2.y\n  };\n}\n\nexports.diff = diff;\n/**\r\n * Scalar multiplication (mutable)\r\n *\r\n * @param v\r\n * @param k\r\n */\n\nfunction mult(v, k) {\n  v.x *= k;\n  v.y *= k;\n  return v;\n}\n\nexports.mult = mult;","\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar lodash_1 = __importDefault(require(\"lodash\"));\n\nvar box_1 = require(\"./box\");\n\nvar point_1 = require(\"./point\");\n/**\r\n * @param n1\r\n * @param n2\r\n * @param padding\r\n *\r\n * @returns true if the nodes overlap\r\n */\n\n\nfunction overlap(n1, n2, padding) {\n  if (padding === void 0) {\n    padding = 0;\n  }\n\n  return overlapX(n1, n2, padding) && overlapY(n1, n2, padding);\n}\n\nexports.overlap = overlap;\n/**\r\n * @param n1\r\n * @param n2\r\n * @param padding\r\n *\r\n * @returns true if the nodes overlap on x\r\n */\n\nfunction overlapX(n1, n2, padding) {\n  if (padding === void 0) {\n    padding = 0;\n  }\n\n  return point_1.normX(n1, n2) < (n1.width + n2.width) / 2 + +padding;\n}\n\nexports.overlapX = overlapX;\n/**\r\n * @param n1\r\n * @param n2\r\n * @param padding\r\n *\r\n * @returns true if the nodes overlap on y\r\n */\n\nfunction overlapY(n1, n2, padding) {\n  if (padding === void 0) {\n    padding = 0;\n  }\n\n  return point_1.normY(n1, n2) < (n1.height + n2.height) / 2 + +padding;\n}\n\nexports.overlapY = overlapY;\n/**\r\n * @param nodes\r\n * @param padding\r\n * @returns true if at least two nodes of the list overlap\r\n */\n\nfunction hasOverlap(nodes, padding) {\n  if (padding === void 0) {\n    padding = 0;\n  }\n\n  var lap = false;\n  var sorted = lodash_1.default.sortBy(nodes, function (node) {\n    return box_1.left(node);\n  });\n  lodash_1.default.forEach(sorted, function (n1, index) {\n    for (var j = index + 1; j < nodes.length; j++) {\n      var n2 = sorted[j];\n\n      if (overlap(n1, n2, padding)) {\n        lap = true;\n        return false; // exit _.forEach\n      } else if (box_1.left(n2) > box_1.right(n1) + padding) break;\n    }\n  });\n  return lap;\n}\n\nexports.hasOverlap = hasOverlap;\n/**\r\n * Get all the overlaps between couple of nodes\r\n * @param map map of nodes having their index as keys\r\n * @param edges\r\n * @param padding\r\n */\n\nfunction edgeOverlap(map, edges, padding) {\n  if (padding === void 0) {\n    padding = 0;\n  }\n\n  var present = false;\n  lodash_1.default.forEach(edges, function (edge) {\n    if (overlap(map[edge.source], map[edge.target], padding)) {\n      present = true;\n      return false;\n    }\n  });\n  return present;\n}\n\nexports.edgeOverlap = edgeOverlap;\n/**\r\n * @param {Node[]} nodes\r\n * @param {number} [padding]\r\n *\r\n * @returns the list of all overlaps of the graph.\r\n */\n\nfunction getAllOverlaps(nodes, padding) {\n  if (padding === void 0) {\n    padding = 0;\n  }\n\n  var sorted = lodash_1.default.sortBy(nodes, function (node) {\n    return box_1.left(node);\n  });\n  var overlaps = [];\n  lodash_1.default.forEach(sorted, function (n1, index) {\n    for (var j = index + 1; j < nodes.length; j++) {\n      var n2 = sorted[j];\n      if (overlap(n1, n2, padding)) overlaps.push([n1, n2]);else if (box_1.left(n2) > box_1.right(n1) + padding) break;\n    }\n  });\n  return overlaps;\n}\n\nexports.getAllOverlaps = getAllOverlaps;","\"use strict\";\n\nfunction __export(m) {\n  for (var p in m) {\n    if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n  }\n}\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\n__export(require(\"./algorithm\"));\n\n__export(require(\"./box\"));\n\n__export(require(\"./conversion\"));\n\n__export(require(\"./cropped\"));\n\n__export(require(\"./delaunay-edges\"));\n\n__export(require(\"./distance\"));\n\n__export(require(\"./node-map\"));\n\n__export(require(\"./overlap\"));\n\n__export(require(\"./point\"));\n\n__export(require(\"./scale\"));\n\n__export(require(\"./vector\"));","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nfunction createFunction(f) {\n  return f;\n}\n\nexports.createFunction = createFunction;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar vector_1 = require(\"./vector\");\n\nvar ROUND_PRECISION = -14;\n\nfunction toCartesian(vector, precision) {\n  if (precision === void 0) {\n    precision = ROUND_PRECISION;\n  }\n\n  return {\n    x: round(vector.length * Math.cos(vector.theta), precision),\n    y: round(vector.length * Math.sin(vector.theta), precision)\n  };\n}\n\nexports.toCartesian = toCartesian;\n\nfunction toPolar(vector, precision) {\n  if (precision === void 0) {\n    precision = ROUND_PRECISION;\n  }\n\n  var rad = Math.atan2(vector.y, vector.x);\n\n  if (rad < 0) {\n    rad = rad + 2 * Math.PI;\n  }\n\n  return {\n    length: vector_1.length(vector),\n    theta: rad,\n    angle: round(rad * 180 / Math.PI, precision)\n  };\n}\n\nexports.toPolar = toPolar;\n\nfunction round(number, precision) {\n  if (precision === void 0) {\n    precision = 0;\n  }\n\n  var multiplier = Math.pow(10, -precision);\n  return Math.round(number * multiplier) / multiplier;\n}\n\nexports.round = round;","\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar lodash_1 = __importDefault(require(\"lodash\"));\n\nvar box_1 = require(\"./box\");\n\nfunction crop(graph) {\n  var minX = box_1.left(box_1.left(graph.nodes));\n  var minY = box_1.top(box_1.top(graph.nodes));\n  lodash_1.default.forEach(graph.nodes, function (n) {\n    n.x -= minX;\n    n.y -= minY;\n  });\n  return graph;\n}\n\nexports.crop = crop;","\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar delaunator_1 = __importDefault(require(\"delaunator\"));\n\nvar lodash_1 = __importDefault(require(\"lodash\"));\n\nvar overlap_1 = require(\"./overlap\");\n\nexports.default = delaunay;\n\nfunction delaunay(nodes) {\n  var del = delaunator_1.default.from(nodes, function (node) {\n    return node.x;\n  }, function (node) {\n    return node.y;\n  });\n  var hastable = [];\n  var triangles = lodash_1.default.chunk(del.triangles, 3); // create edges\n\n  var edges = [];\n  lodash_1.default.forEach(triangles, function (triangle) {\n    triangle.sort(function (a, b) {\n      return +a - +b;\n    });\n    var a = +triangle[0],\n        b = +triangle[1],\n        c = +triangle[2];\n    if (addable(hastable, a, b)) edges.push({\n      source: nodes[a].index,\n      target: nodes[b].index\n    });\n    if (addable(hastable, b, c)) edges.push({\n      source: nodes[b].index,\n      target: nodes[c].index\n    });\n    if (addable(hastable, a, c)) edges.push({\n      source: nodes[a].index,\n      target: nodes[c].index\n    });\n  });\n  return lodash_1.default.sortBy(edges, ['source', 'target']);\n}\n\nexports.delaunay = delaunay;\n\nfunction addable(hastable, i, j) {\n  if (hastable[i] === void 0 || hastable[i][j] !== true) {\n    if (!hastable[i]) hastable[i] = [];\n    hastable[i][j] = true;\n    return true;\n  }\n\n  return false;\n}\n/**\r\n * augment the delaunay triangulation with the overlaping nodes\r\n * @param nodes list of nodes\r\n * @param padding padding between nodes\r\n */\n\n\nfunction augmented(nodes, padding) {\n  return merge(delaunay(nodes), overlaps(nodes, padding));\n}\n\nexports.augmented = augmented;\n/**\r\n * Get all overlaps of the list of nodes\r\n * @param nodes\r\n * @param padding\r\n */\n\nfunction overlaps(nodes, padding) {\n  return lodash_1.default(overlap_1.getAllOverlaps(nodes, padding)).map(function (pair) {\n    pair.sort(function (a, b) {\n      return a.index - b.index;\n    });\n    return {\n      source: pair[0].index,\n      target: pair[1].index\n    };\n  }).sortBy(['source', 'target']).value();\n}\n/**\r\n * Merging multiple edge list while removing redundancy\r\n * @param edges1\r\n * @param edges2\r\n */\n\n\nfunction merge(edges1, edges2) {\n  var _a = edges1.length <= edges2.length ? [edges1, edges2] : [edges2, edges1],\n      iterated = _a[0],\n      iteratee = _a[1];\n\n  var added = [];\n  lodash_1.default.forEach(iterated, function (e1) {\n    var empty = true;\n    lodash_1.default.forEach(iteratee, function (e2) {\n      if (e1.source === e2.source && e1.target === e2.target) {\n        empty = false;\n        return false;\n      }\n\n      if (e1.source === e2.source && e1.target < e2.target || e1.source < e2.source) {\n        added.push(e1);\n        empty = false;\n        return false;\n      }\n    });\n    if (empty) added.push(e1);\n  });\n  return lodash_1.default.concat(added, iteratee);\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar point_1 = require(\"./point\");\n\nvar vector_1 = require(\"./vector\");\n/**\r\n * @param n1\r\n * @param n2\r\n * @param padding\r\n *\r\n * @returns the closest position of n2 relative to n1 while avoiding overlapping, along the (n1,n2) line.\r\n */\n\n\nfunction optimalVector(n1, n2, padding) {\n  if (padding === void 0) {\n    padding = 0;\n  } // optimal distance for each axis\n\n\n  var desired = {\n    x: +(n1.width + n2.width) / 2 + +padding,\n    y: +(n1.height + n2.height) / 2 + +padding\n  }; // distances\n\n  var actual = point_1.Δ(n1, n2);\n\n  if (actual.x === 0 && actual.y === 0) {\n    return {\n      x: 0,\n      y: 0\n    };\n  } // ratios\n\n\n  var widthRatio = desired.x / actual.x,\n      heightRatio = desired.y / actual.y;\n  var unOverlapRatio = Math.min(Math.abs(widthRatio), Math.abs(heightRatio));\n  return vector_1.mult(actual, unOverlapRatio);\n}\n\nexports.optimalVector = optimalVector;\n/**\r\n *\r\n * @param n1\r\n * @param n2\r\n * @param padding\r\n *\r\n * @returns the minimal vector between two nodes ; the closest position of n2 relative to n1 according his current position, while avoiding overlapping\r\n */\n\nfunction minimalVector(n1, n2, padding) {\n  if (padding === void 0) {\n    padding = 0;\n  }\n\n  var Δx_n1n2 = point_1.Δx(n1, n2);\n  var Δy_n1n2 = point_1.Δy(n1, n2);\n\n  if (Δx_n1n2 <= Δy_n1n2) {\n    return {\n      x: Δx_n1n2 + 2 * padding,\n      y: 0\n    };\n  } else {\n    return {\n      x: 0,\n      y: Δy_n1n2 + 2 * padding\n    };\n  }\n}\n\nexports.minimalVector = minimalVector;","\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar lodash_1 = __importDefault(require(\"lodash\"));\n\nfunction nodeMap(nodes) {\n  var aggreg = {};\n  lodash_1.default.forEach(nodes, function (node) {\n    aggreg[node.index] = node;\n  });\n  return aggreg;\n}\n\nexports.nodeMap = nodeMap;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\r\n *\r\n * @param initial\r\n * @param frame\r\n *\r\n * @returns function which converts the coordinate for the projection\r\n */\n\nfunction createScale(initial, frame) {\n  var scale = function scale(initial) {\n    return scale.ratio * initial;\n  };\n\n  scale.ratio = Math.min(frame.width / initial.width, frame.height / initial.height);\n  return scale;\n}\n\nexports.createScale = createScale;","\"use strict\";\n/**\r\n * Implementation of the Scale algorithm\r\n *\r\n * Scales up the size of the graph until there is no more overlap\r\n */\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar lodash_1 = __importDefault(require(\"lodash\"));\n\nvar agora_graph_1 = require(\"agora-graph\");\n/**\r\n * Executes the Scale algorithm for this graph\r\n *\r\n * @param {Graph} graph the graph to update\r\n * @param {object} options to pass to the algorith\r\n * @param {number} options.padding padding to add between nodes\r\n */\n\n\nexports.scaling = agora_graph_1.createFunction(function (graph, options) {\n  if (options === void 0) {\n    options = {\n      padding: 0\n    };\n  }\n\n  var scaleRatio = getMaxOverlapRatio(graph.nodes, options.padding); // scale it up\n\n  lodash_1.default.forEach(graph.nodes, function (n) {\n    n.x *= +scaleRatio;\n    n.y *= +scaleRatio;\n  });\n  var x_origin = agora_graph_1.minX(agora_graph_1.minX(graph.nodes));\n  var y_origin = agora_graph_1.minY(agora_graph_1.minY(graph.nodes)); // shift to origin\n\n  lodash_1.default.forEach(graph.nodes, function (n) {\n    n.x -= x_origin;\n    n.y -= y_origin;\n  });\n  return {\n    graph: graph\n  };\n});\nexports.ScalingAlgorithm = {\n  name: 'Scaling',\n  algorithm: exports.scaling\n};\nexports.default = exports.ScalingAlgorithm;\n/**\r\n * find the biggest ratio for overlapping nodes\r\n * @param nodes\r\n * @param [padding=0]\r\n */\n\nfunction getMaxOverlapRatio(nodes, padding) {\n  if (padding === void 0) {\n    padding = 0;\n  }\n\n  var maxOverlapRatio = 1;\n  var overlapGroups = agora_graph_1.getAllOverlaps(nodes);\n  lodash_1.default.forEach(overlapGroups, function (group) {\n    for (var i = 0; i < group.length; i++) {\n      var u = group[i];\n\n      for (var j = i + 1; j < group.length; j++) {\n        var v = group[j];\n\n        if (agora_graph_1.overlap(u, v, padding)) {\n          var actualDist = agora_graph_1.norm(u, v);\n\n          if (actualDist !== 0) {\n            var optimalDist = agora_graph_1.length(agora_graph_1.optimalVector(u, v, padding));\n            var ratio = optimalDist / actualDist;\n\n            if (maxOverlapRatio < ratio) {\n              maxOverlapRatio = ratio;\n            }\n          }\n        }\n      }\n    }\n  });\n  return maxOverlapRatio;\n}"],"sourceRoot":""}