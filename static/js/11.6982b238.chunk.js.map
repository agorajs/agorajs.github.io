{"version":3,"sources":["../node_modules/agora-criteria/dist/utils.js","../node_modules/d3-polygon/src/area.js","../node_modules/d3-polygon/src/centroid.js","../node_modules/d3-polygon/src/cross.js","../node_modules/d3-polygon/src/hull.js","../node_modules/d3-polygon/src/contains.js","../node_modules/d3-polygon/src/length.js","../node_modules/d3-polygon/src/index.js","../node_modules/agora-criteria/dist/global-shape/convex-hull_standard-deviation.js"],"names":["Object","defineProperty","exports","value","criteriaWrap","_a","name","_criteria","criteria","_short","short","initial","updated","nodes","length","Error","a","i","n","polygon","b","area","c","x","y","k","lexicographicOrder","computeUpperHullIndexes","points","indexes","size","cross","slice","sortedPoints","Array","flippedPoints","sort","upperIndexes","lowerIndexes","skipLeft","skipRight","hull","push","x1","y1","p","point","x0","y0","inside","xa","ya","xb","yb","perimeter","Math","sqrt","__importStar","this","mod","__esModule","result","hasOwnProperty","call","d3","_","agora_graph_1","utils_1","calculateConvexHullDistances","center","polygonCentroid","centeredHull","map","pos","rays","angle","theta","round","PI","lines","elements","sorted","sortBy","start","end","lastEl","buffer","getLines","toPolar","distances","forEach","ray","line","_i","lines_1","getIntersectingLine","cartesianRay","toCartesian","intersection","line1","line2","denominator","numerator1","numerator2","lineIntersection","magnitude","convertNodes","flatMap","t","top","l","left","r","right","bottom","shapePreservation","initialHull","polygonHull","updatedHull","error","initialDistances","updatedDistances","d","mean_d","mean","sumBy","d_a","pow","GlobalShapeConvexHullStandardDeviationCriteria","default"],"mappings":"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","file":"static/js/11.6982b238.chunk.js","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nfunction criteriaWrap(_a) {\n  var name = _a.name,\n      _criteria = _a.criteria,\n      _short = _a.short;\n  return {\n    name: name,\n    short: _short,\n    criteria: function criteria(initial, updated) {\n      if (initial.nodes.length !== updated.nodes.length) {\n        //* ignoring console because it's captured by the exception\n\n        /*\r\n        console.error(\r\n        'criteria', // family\r\n        criteria.short, // type\r\n        'abording', // action\r\n        'not the same number of nodes' // reason\r\n        ); */\n        throw Error(\"Criteria \" + (_short ? _short : name) + \" abording : not same number of nodes\");\n      }\n\n      return _criteria(initial, updated);\n    }\n  };\n}\n\nexports.criteriaWrap = criteriaWrap;","export default function (polygon) {\n  var i = -1,\n      n = polygon.length,\n      a,\n      b = polygon[n - 1],\n      area = 0;\n\n  while (++i < n) {\n    a = b;\n    b = polygon[i];\n    area += a[1] * b[0] - a[0] * b[1];\n  }\n\n  return area / 2;\n}","export default function (polygon) {\n  var i = -1,\n      n = polygon.length,\n      x = 0,\n      y = 0,\n      a,\n      b = polygon[n - 1],\n      c,\n      k = 0;\n\n  while (++i < n) {\n    a = b;\n    b = polygon[i];\n    k += c = a[0] * b[1] - b[0] * a[1];\n    x += (a[0] + b[0]) * c;\n    y += (a[1] + b[1]) * c;\n  }\n\n  return k *= 3, [x / k, y / k];\n}","// Returns the 2D cross product of AB and AC vectors, i.e., the z-component of\n// the 3D cross product in a quadrant I Cartesian coordinate system (+x is\n// right, +y is up). Returns a positive value if ABC is counter-clockwise,\n// negative if clockwise, and zero if the points are collinear.\nexport default function (a, b, c) {\n  return (b[0] - a[0]) * (c[1] - a[1]) - (b[1] - a[1]) * (c[0] - a[0]);\n}","import cross from \"./cross\";\n\nfunction lexicographicOrder(a, b) {\n  return a[0] - b[0] || a[1] - b[1];\n} // Computes the upper convex hull per the monotone chain algorithm.\n// Assumes points.length >= 3, is sorted by x, unique in y.\n// Returns an array of indices into points in left-to-right order.\n\n\nfunction computeUpperHullIndexes(points) {\n  var n = points.length,\n      indexes = [0, 1],\n      size = 2;\n\n  for (var i = 2; i < n; ++i) {\n    while (size > 1 && cross(points[indexes[size - 2]], points[indexes[size - 1]], points[i]) <= 0) {\n      --size;\n    }\n\n    indexes[size++] = i;\n  }\n\n  return indexes.slice(0, size); // remove popped points\n}\n\nexport default function (points) {\n  if ((n = points.length) < 3) return null;\n  var i,\n      n,\n      sortedPoints = new Array(n),\n      flippedPoints = new Array(n);\n\n  for (i = 0; i < n; ++i) {\n    sortedPoints[i] = [+points[i][0], +points[i][1], i];\n  }\n\n  sortedPoints.sort(lexicographicOrder);\n\n  for (i = 0; i < n; ++i) {\n    flippedPoints[i] = [sortedPoints[i][0], -sortedPoints[i][1]];\n  }\n\n  var upperIndexes = computeUpperHullIndexes(sortedPoints),\n      lowerIndexes = computeUpperHullIndexes(flippedPoints); // Construct the hull polygon, removing possible duplicate endpoints.\n\n  var skipLeft = lowerIndexes[0] === upperIndexes[0],\n      skipRight = lowerIndexes[lowerIndexes.length - 1] === upperIndexes[upperIndexes.length - 1],\n      hull = []; // Add upper hull in right-to-l order.\n  // Then add lower hull in left-to-right order.\n\n  for (i = upperIndexes.length - 1; i >= 0; --i) {\n    hull.push(points[sortedPoints[upperIndexes[i]][2]]);\n  }\n\n  for (i = +skipLeft; i < lowerIndexes.length - skipRight; ++i) {\n    hull.push(points[sortedPoints[lowerIndexes[i]][2]]);\n  }\n\n  return hull;\n}","export default function (polygon, point) {\n  var n = polygon.length,\n      p = polygon[n - 1],\n      x = point[0],\n      y = point[1],\n      x0 = p[0],\n      y0 = p[1],\n      x1,\n      y1,\n      inside = false;\n\n  for (var i = 0; i < n; ++i) {\n    p = polygon[i], x1 = p[0], y1 = p[1];\n    if (y1 > y !== y0 > y && x < (x0 - x1) * (y - y1) / (y0 - y1) + x1) inside = !inside;\n    x0 = x1, y0 = y1;\n  }\n\n  return inside;\n}","export default function (polygon) {\n  var i = -1,\n      n = polygon.length,\n      b = polygon[n - 1],\n      xa,\n      ya,\n      xb = b[0],\n      yb = b[1],\n      perimeter = 0;\n\n  while (++i < n) {\n    xa = xb;\n    ya = yb;\n    b = polygon[i];\n    xb = b[0];\n    yb = b[1];\n    xa -= xb;\n    ya -= yb;\n    perimeter += Math.sqrt(xa * xa + ya * ya);\n  }\n\n  return perimeter;\n}","export { default as polygonArea } from \"./area\";\nexport { default as polygonCentroid } from \"./centroid\";\nexport { default as polygonHull } from \"./hull\";\nexport { default as polygonContains } from \"./contains\";\nexport { default as polygonLength } from \"./length\";","\"use strict\";\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n  }\n  result[\"default\"] = mod;\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar d3 = __importStar(require(\"d3-polygon\"));\n\nvar _ = __importStar(require(\"lodash\"));\n\nvar agora_graph_1 = require(\"agora-graph\");\n\nvar utils_1 = require(\"../utils\");\n/**\r\n * TODO: SSS12\r\n */\n\n\nexports.shapePreservation = function (initial, updated) {\n  // STEP 1 : retrieve convex hull\n  var initialHull = d3.polygonHull(convertNodes(initial.nodes));\n  var updatedHull = d3.polygonHull(convertNodes(updated.nodes)); // STEP 1.1 : check for errors\n\n  if (initialHull === null || updatedHull === null) return {\n    value: -1,\n    error: 'could not compute initial or updated convex hull'\n  }; // DO STEP 2-3-4-5\n\n  var initialDistances = calculateConvexHullDistances(initialHull);\n  var updatedDistances = calculateConvexHullDistances(updatedHull);\n  var d = [];\n\n  for (var i = 0; i < initialDistances.length; i++) {\n    d.push(updatedDistances[i] / initialDistances[i]);\n  }\n\n  var mean_d = _.mean(d);\n\n  var value = _.sumBy(d, function (d_a) {\n    return Math.pow(d_a - mean_d, 2);\n  });\n\n  return {\n    value: value,\n    initial: initialDistances,\n    updated: updatedDistances\n  };\n};\n\nfunction calculateConvexHullDistances(hull) {\n  // STEP 2 get center of the hull and set as center\n  var center = d3.polygonCentroid(hull);\n\n  var centeredHull = _.map(hull, function (pos) {\n    return [pos[0] - center[0], pos[1] - center[1]];\n  }); // STEP 3 create radian lines from center each 10 degrees.\n\n\n  var rays = [];\n\n  for (var angle = 0; angle < 360; angle += 10) {\n    rays.push({\n      angle: angle,\n      length: 1,\n      theta: agora_graph_1.round(angle * (Math.PI / 180), -14)\n    });\n  } // STEP 4 convert point of the hull to polar coordinates (to know which line do i need to raytrace)\n\n\n  var elements = _.map(centeredHull, function (pos) {\n    return [pos, agora_graph_1.toPolar({\n      x: pos[0],\n      y: pos[1]\n    })];\n  });\n\n  var lines = getLines(elements);\n  var distances = [];\n\n  _.forEach(rays, function (ray) {\n    var line = getIntersectingLine(lines, ray);\n    var cartesianRay = agora_graph_1.toCartesian(ray);\n    var intersection = lineIntersection({\n      start: [0, 0],\n      end: [cartesianRay.x, cartesianRay.y]\n    }, {\n      start: line.start[0],\n      end: line.end[0]\n    });\n    if (intersection) distances.push(agora_graph_1.magnitude(intersection));else throw Error('it is supposed to intersect :(');\n  });\n\n  return distances;\n}\n\nexports.calculateConvexHullDistances = calculateConvexHullDistances;\n\nfunction getIntersectingLine(lines, ray) {\n  for (var _i = 0, lines_1 = lines; _i < lines_1.length; _i++) {\n    var line = lines_1[_i];\n    if (line.start[1] <= ray.angle && line.end[1] > ray.angle) return line;\n  } // should never be in this case\n\n\n  throw Error('Unreachable error, how did you manage to get here');\n  return lines[0];\n}\n\nfunction getLines(elements) {\n  var sorted = _.sortBy(elements, function (a) {\n    return a[1].angle;\n  });\n\n  if (sorted.length === 0) {\n    return [];\n  }\n\n  if (sorted.length === 1) {\n    return [{\n      start: [sorted[0][0], sorted[0][1].angle],\n      end: [sorted[0][0], sorted[0][1].angle + 360]\n    }];\n  }\n\n  var lastEl = sorted[sorted.length - 1];\n  var buffer = sorted[0];\n  var lines = [{\n    start: [lastEl[0], lastEl[1].angle - 360],\n    end: [buffer[0], buffer[1].angle]\n  }];\n\n  for (var i = 1; i < sorted.length; i++) {\n    lines.push({\n      start: [buffer[0], buffer[1].angle],\n      end: [sorted[i][0], sorted[i][1].angle]\n    });\n    buffer = sorted[i];\n  }\n\n  lines.push({\n    start: [buffer[0], buffer[1].angle],\n    end: [sorted[0][0], sorted[0][1].angle + 360]\n  });\n  return lines;\n}\n\nfunction lineIntersection(line1, line2) {\n  // if the lines intersect, the result contains the x and y of the intersection (treating the lines as infinite)\n  var denominator = (line2.end[1] - line2.start[1]) * (line1.end[0] - line1.start[0]) - (line2.end[0] - line2.start[0]) * (line1.end[1] - line1.start[1]);\n\n  if (denominator == 0) {\n    return null;\n  }\n\n  var a = line1.start[1] - line2.start[1];\n  var b = line1.start[0] - line2.start[0];\n  var numerator1 = (line2.end[0] - line2.start[0]) * a - (line2.end[1] - line2.start[1]) * b;\n  var numerator2 = (line1.end[0] - line1.start[0]) * a - (line1.end[1] - line1.start[1]) * b;\n  a = numerator1 / denominator;\n  b = numerator2 / denominator; // if we cast these lines infinitely in both directions, they intersect here:\n\n  return {\n    x: line1.start[0] + a * (line1.end[0] - line1.start[0]),\n    y: line1.start[1] + a * (line1.end[1] - line1.start[1])\n  };\n}\n\nfunction convertNodes(nodes) {\n  // TODO: add node boxes\n  return _.flatMap(nodes, function (n) {\n    var t = agora_graph_1.top(n),\n        l = agora_graph_1.left(n),\n        r = agora_graph_1.right(n),\n        b = agora_graph_1.bottom(n);\n    return [[l, t], [r, t], [r, b], [l, b]];\n  });\n}\n\nexports.GlobalShapeConvexHullStandardDeviationCriteria = utils_1.criteriaWrap({\n  criteria: exports.shapePreservation,\n  name: 'global-shape/convex-hull/standard-deviation',\n  short: 'gs_ch_sd'\n});\nexports.default = exports.GlobalShapeConvexHullStandardDeviationCriteria;"],"sourceRoot":""}