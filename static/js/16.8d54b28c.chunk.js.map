{"version":3,"sources":["../node_modules/agora-pfs/dist/index.js"],"names":["__importDefault","this","mod","__esModule","Object","defineProperty","exports","value","lodash_1","require","agora_graph_1","same","nodes","index","callback","k","length","delta","node1","node2","padding","overlap","diff","optimalVector","vector","x","y","pfs","createFunction","graph","options","default","forEach","n","up","sort","a","b","i","n1","n2","maxDelta","m","j","move","Math","abs","node","undefined","scanX","scanY","PFSAlgorithm","name","algorithm"],"mappings":"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","file":"static/js/16.8d54b28c.chunk.js","sourcesContent":["\"use strict\";\r\n/**\r\n * Implementation of the Push Force Scan (PFS) algorithm\r\n *\r\n * Kazuo Misue, Peter Eades, Wei Lai, Kozo Sugiyama,\r\n * Layout Adjustment and the Mental Map,\r\n * Journal of Visual Languages & Computing,\r\n * Volume 6, Issue 2,\r\n * 1995,\r\n * Pages 183-210,\r\n * ISSN 1045-926X,\r\n * https://doi.org/10.1006/jvlc.1995.1010.\r\n * (http://www.sciencedirect.com/science/article/pii/S1045926X85710105)\r\n */\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar lodash_1 = __importDefault(require(\"lodash\"));\r\nvar agora_graph_1 = require(\"agora-graph\");\r\n/**\r\n * Executes the Push Force Scan (PFS) algorithm for this graph\r\n *\r\n * @param {Graph} graph the graph to update\r\n * @param {object} [options] options to pass to the algorith\r\n * @param {number} options.padding padding to add between nodes\r\n *\r\n * @returns {Result} the updated graph\r\n */\r\nexports.pfs = agora_graph_1.createFunction(function (graph, options) {\r\n    if (options === void 0) { options = { padding: 0 }; }\r\n    lodash_1.default.forEach(graph.nodes, function (n) {\r\n        n.up = { x: n.x, y: n.y };\r\n    });\r\n    graph.nodes.sort(function (a, b) { return a.x - b.x; });\r\n    scanX(graph.nodes, options.padding);\r\n    graph.nodes.sort(function (a, b) { return a.y - b.y; });\r\n    scanY(graph.nodes, options.padding);\r\n    lodash_1.default.forEach(graph.nodes, function (n) {\r\n        if (n.up === undefined)\r\n            throw 'cannot update undefined updated position for' + n;\r\n        n.x = n.up.x;\r\n        n.y = n.up.y;\r\n        delete n.up; // PERF : maybe heavy cost\r\n    });\r\n    return { graph: graph };\r\n});\r\nexports.PFSAlgorithm = {\r\n    name: 'PFS',\r\n    algorithm: exports.pfs\r\n};\r\nexports.default = exports.PFSAlgorithm;\r\n/**\r\n * Scans and updates the list of nodes accordingly on the x axis\r\n * @param {Node[]} nodes The list of nodes\r\n * @param {number} [padding] the padding\r\n */\r\nfunction scanX(nodes, padding) {\r\n    var i = 0;\r\n    while (i < nodes.length - 1) {\r\n        var k = same(nodes, i, function (n1, n2) { return n1.x === n2.x; });\r\n        var maxDelta = 0;\r\n        for (var m = i; m <= k; m++) {\r\n            for (var j = k + 1; j < nodes.length; j++) {\r\n                var move = delta(nodes[m], nodes[j], padding).x;\r\n                if (Math.abs(move) > Math.abs(maxDelta)) {\r\n                    maxDelta = move;\r\n                }\r\n            }\r\n        }\r\n        for (var j = k + 1; j < nodes.length; j++) {\r\n            var node = nodes[j];\r\n            if (node.up === undefined)\r\n                throw 'cannot update undefined updated position for' + node;\r\n            node.up.x = node.up.x + maxDelta;\r\n        }\r\n        i = k + 1;\r\n    }\r\n}\r\n/**\r\n * Scans and updates the list of nodes accordingly on the x axis\r\n * @param {Node[]} nodes The list of nodes\r\n * @param {number} [padding] the padding\r\n */\r\nfunction scanY(nodes, padding) {\r\n    var i = 0;\r\n    while (i < nodes.length - 1) {\r\n        var k = same(nodes, i, function (n1, n2) { return n1.y === n2.y; });\r\n        var maxDelta = 0;\r\n        for (var m = i; m <= k; m++) {\r\n            for (var j = k + 1; j < nodes.length; j++) {\r\n                var move = delta(nodes[m], nodes[j], padding).y;\r\n                if (Math.abs(move) > Math.abs(maxDelta)) {\r\n                    maxDelta = move;\r\n                }\r\n            }\r\n        }\r\n        for (var j = k + 1; j < nodes.length; j++) {\r\n            var node = nodes[j];\r\n            if (node.up === undefined)\r\n                throw 'cannot update undefined updated position for' + node;\r\n            node.up.y = node.up.y + maxDelta;\r\n        }\r\n        i = k + 1;\r\n    }\r\n}\r\n/**\r\n * Checks the last index having being the same, based on the callback\r\n * @param {Node[]} nodes list of nodes\r\n * @param {number} index index to check if same\r\n * @param {{(n1: Node, n2: Node)=> boolean}} callback\r\n */\r\nfunction same(nodes, index, callback) {\r\n    var k = index;\r\n    while (k < nodes.length - 1) {\r\n        if (!callback(nodes[index], nodes[k + 1]))\r\n            return k;\r\n        k++;\r\n    }\r\n    return k;\r\n}\r\n/**\r\n * Computes the delta between two nodes, if the nodes are not overlapping, returns 0\r\n *\r\n * @param {Node} node1 the first node\r\n * @param {Node} node2 The second node\r\n * @param {number} [padding=0] The padding\r\n *\r\n * @returns {{x: number, y:number}} 0 if no overlap, a value otherwise\r\n */\r\nfunction delta(node1, node2, padding) {\r\n    if (padding === void 0) { padding = 0; }\r\n    if (!agora_graph_1.overlap(node1, node2, padding))\r\n        return { x: 0, y: 0 };\r\n    return agora_graph_1.diff(agora_graph_1.optimalVector(node1, node2, padding), agora_graph_1.vector(node1, node2));\r\n}\r\n"],"sourceRoot":""}