{"version":3,"sources":["../node_modules/agora-pfs/dist/index.js"],"names":["__importDefault","this","mod","__esModule","Object","defineProperty","exports","value","lodash_1","agora_graph_1","same","nodes","index","callback","k","length","delta","node1","node2","padding","overlap","diff","optimalVector","vector","x","y","pfs","createFunction","graph","options","default","forEach","n","up","sort","a","b","i","n1","n2","maxDelta","m","j","move","Math","abs","node","undefined","scanX","scanY","PFSAlgorithm","name","algorithm"],"mappings":"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","file":"static/js/16.df73de44.chunk.js","sourcesContent":["\"use strict\";\n/**\r\n * Implementation of the Push Force Scan (PFS) algorithm\r\n *\r\n * Kazuo Misue, Peter Eades, Wei Lai, Kozo Sugiyama,\r\n * Layout Adjustment and the Mental Map,\r\n * Journal of Visual Languages & Computing,\r\n * Volume 6, Issue 2,\r\n * 1995,\r\n * Pages 183-210,\r\n * ISSN 1045-926X,\r\n * https://doi.org/10.1006/jvlc.1995.1010.\r\n * (http://www.sciencedirect.com/science/article/pii/S1045926X85710105)\r\n */\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar lodash_1 = __importDefault(require(\"lodash\"));\n\nvar agora_graph_1 = require(\"agora-graph\");\n/**\r\n * Executes the Push Force Scan (PFS) algorithm for this graph\r\n *\r\n * @param {Graph} graph the graph to update\r\n * @param {object} [options] options to pass to the algorith\r\n * @param {number} options.padding padding to add between nodes\r\n *\r\n * @returns {Result} the updated graph\r\n */\n\n\nexports.pfs = agora_graph_1.createFunction(function (graph, options) {\n  if (options === void 0) {\n    options = {\n      padding: 0\n    };\n  }\n\n  lodash_1.default.forEach(graph.nodes, function (n) {\n    n.up = {\n      x: n.x,\n      y: n.y\n    };\n  });\n  graph.nodes.sort(function (a, b) {\n    return a.x - b.x;\n  });\n  scanX(graph.nodes, options.padding);\n  graph.nodes.sort(function (a, b) {\n    return a.y - b.y;\n  });\n  scanY(graph.nodes, options.padding);\n  lodash_1.default.forEach(graph.nodes, function (n) {\n    if (n.up === undefined) throw 'cannot update undefined updated position for' + n;\n    n.x = n.up.x;\n    n.y = n.up.y;\n    delete n.up; // PERF : maybe heavy cost\n  });\n  return {\n    graph: graph\n  };\n});\nexports.PFSAlgorithm = {\n  name: 'PFS',\n  algorithm: exports.pfs\n};\nexports.default = exports.PFSAlgorithm;\n/**\r\n * Scans and updates the list of nodes accordingly on the x axis\r\n * @param {Node[]} nodes The list of nodes\r\n * @param {number} [padding] the padding\r\n */\n\nfunction scanX(nodes, padding) {\n  var i = 0;\n\n  while (i < nodes.length - 1) {\n    var k = same(nodes, i, function (n1, n2) {\n      return n1.x === n2.x;\n    });\n    var maxDelta = 0;\n\n    for (var m = i; m <= k; m++) {\n      for (var j = k + 1; j < nodes.length; j++) {\n        var move = delta(nodes[m], nodes[j], padding).x;\n\n        if (Math.abs(move) > Math.abs(maxDelta)) {\n          maxDelta = move;\n        }\n      }\n    }\n\n    for (var j = k + 1; j < nodes.length; j++) {\n      var node = nodes[j];\n      if (node.up === undefined) throw 'cannot update undefined updated position for' + node;\n      node.up.x = node.up.x + maxDelta;\n    }\n\n    i = k + 1;\n  }\n}\n/**\r\n * Scans and updates the list of nodes accordingly on the x axis\r\n * @param {Node[]} nodes The list of nodes\r\n * @param {number} [padding] the padding\r\n */\n\n\nfunction scanY(nodes, padding) {\n  var i = 0;\n\n  while (i < nodes.length - 1) {\n    var k = same(nodes, i, function (n1, n2) {\n      return n1.y === n2.y;\n    });\n    var maxDelta = 0;\n\n    for (var m = i; m <= k; m++) {\n      for (var j = k + 1; j < nodes.length; j++) {\n        var move = delta(nodes[m], nodes[j], padding).y;\n\n        if (Math.abs(move) > Math.abs(maxDelta)) {\n          maxDelta = move;\n        }\n      }\n    }\n\n    for (var j = k + 1; j < nodes.length; j++) {\n      var node = nodes[j];\n      if (node.up === undefined) throw 'cannot update undefined updated position for' + node;\n      node.up.y = node.up.y + maxDelta;\n    }\n\n    i = k + 1;\n  }\n}\n/**\r\n * Checks the last index having being the same, based on the callback\r\n * @param {Node[]} nodes list of nodes\r\n * @param {number} index index to check if same\r\n * @param {{(n1: Node, n2: Node)=> boolean}} callback\r\n */\n\n\nfunction same(nodes, index, callback) {\n  var k = index;\n\n  while (k < nodes.length - 1) {\n    if (!callback(nodes[index], nodes[k + 1])) return k;\n    k++;\n  }\n\n  return k;\n}\n/**\r\n * Computes the delta between two nodes, if the nodes are not overlapping, returns 0\r\n *\r\n * @param {Node} node1 the first node\r\n * @param {Node} node2 The second node\r\n * @param {number} [padding=0] The padding\r\n *\r\n * @returns {{x: number, y:number}} 0 if no overlap, a value otherwise\r\n */\n\n\nfunction delta(node1, node2, padding) {\n  if (padding === void 0) {\n    padding = 0;\n  }\n\n  if (!agora_graph_1.overlap(node1, node2, padding)) return {\n    x: 0,\n    y: 0\n  };\n  return agora_graph_1.diff(agora_graph_1.optimalVector(node1, node2, padding), agora_graph_1.vector(node1, node2));\n}"],"sourceRoot":""}